{"version":3,"sources":["webpack:///component---src-pages-guides-maybeasync-eitherasync-for-haskellers-js-4b56acda1ac5f39c23ff.js","webpack:///./src/pages/guides/maybeasync-eitherasync-for-haskellers.js"],"names":["webpackJsonp","227","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_react","_react2","_styledComponents","_styledComponents2","_layout","_layout2","_HL","_HL2","_reactSyntaxHighlighter","_reactSyntaxHighlighter2","_googlecode","_googlecode2","MaybeApiGuide","styled","div","withConfig","displayName","a","props","createElement","location","language","style","highlightStyle","href"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,EAASC,GAEhC,YA4BA,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GA1BvFH,EAAQI,YAAa,CCPtB,IAAAE,GAAAL,EAAA,GDWKM,EAAUL,EAAuBI,GCVtCE,EAAAP,EAAA,GDcKQ,EAAqBP,EAAuBM,GCbjDE,EAAAT,EAAA,IDiBKU,EAAWT,EAAuBQ,GChBvCE,EAAAX,EAAA,IDoBKY,EAAOX,EAAuBU,GCnBnCE,EAAAb,EAAA,IDuBKc,EAA2Bb,EAAuBY,GCtBvDE,EAAAf,EAAA,ID0BKgB,EAAef,EAAuBc,GCFrCE,GAtBOC,UAAOC,IAAdC,YAAAC,YAAA,4KASaH,UAAOI,EAApBF,YAAAC,YAAA,sMAagB,SAAAE,GAAA,MACpBjB,GAAAF,QAAAoB,cAACd,EAAAN,SAAOqB,SAAUF,EAAME,UACtBnB,EAAAF,QAAAoB,cAAA,uDADF,yJAISlB,EAAAF,QAAAoB,cAAA,WAJT,uMAO0DlB,EAAAF,QAAAoB,cAAA,WAP1D,mOAYElB,EAAAF,QAAAoB,cAACV,EAAAV,SAAkBsB,SAAS,UAAUC,MAAOC,WAA7C,qUAZF,0MAyBqDtB,EAAAF,QAAAoB,cAAA,WAzBrD,+DA2BElB,EAAAF,QAAAoB,cAACV,EAAAV,SAAkBsB,SAAS,aAAaC,MAAOC,WAAhD,6fA3BF,yMA2CqDtB,EAAAF,QAAAoB,cAAA,WA3CrD,wJA6C2ElB,EAAAF,QAAAoB,cAAA,WA7C3E,kKAgDWlB,EAAAF,QAAAoB,cAAA,WAhDX,sGAmDElB,EAAAF,QAAAoB,cAAA,mCACAlB,EAAAF,QAAAoB,cAAA,UACElB,EAAAF,QAAAoB,cAAA,UAAK,gBAAL,kBACAlB,EAAAF,QAAAoB,cAAA,UAAK,oBAAL,qBACAlB,EAAAF,QAAAoB,cAAA,kDACuClB,EAAAF,QAAAoB,cAACZ,EAAAR,QAAD,gCADvC,gFAIAE,EAAAF,QAAAoB,cAAA,0JAIAlB,EAAAF,QAAAoB,cAAA,6BACAlB,EAAAF,QAAAoB,cAAA,gEACsD,IACpDlB,EAAAF,QAAAoB,cAAA,KAAGK,KAAK,gHAAR,wBAFF,KAMAvB,EAAAF,QAAAoB,cAAA,0DDuCLzB,GAAQK,QClCMa,EDmCdnB,EAAOC,QAAUA,EAAiB","file":"component---src-pages-guides-maybeasync-eitherasync-for-haskellers-js-4b56acda1ac5f39c23ff.js","sourcesContent":["webpackJsonp([193010934976124],{\n\n/***/ 227:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _styledComponents = __webpack_require__(9);\n\t\n\tvar _styledComponents2 = _interopRequireDefault(_styledComponents);\n\t\n\tvar _layout = __webpack_require__(22);\n\t\n\tvar _layout2 = _interopRequireDefault(_layout);\n\t\n\tvar _HL = __webpack_require__(59);\n\t\n\tvar _HL2 = _interopRequireDefault(_HL);\n\t\n\tvar _reactSyntaxHighlighter = __webpack_require__(25);\n\t\n\tvar _reactSyntaxHighlighter2 = _interopRequireDefault(_reactSyntaxHighlighter);\n\t\n\tvar _googlecode = __webpack_require__(30);\n\t\n\tvar _googlecode2 = _interopRequireDefault(_googlecode);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Note = _styledComponents2.default.div.withConfig({\n\t  displayName: 'maybeasync-eitherasync-for-haskellers__Note'\n\t})(['display:inline-block;background-color:#fcf4cd;border:0 solid #f7e070;border-left-width:8px;padding:10px;margin:10px 0;']);\n\t\n\tvar MethodName = _styledComponents2.default.a.withConfig({\n\t  displayName: 'maybeasync-eitherasync-for-haskellers__MethodName'\n\t})(['font-size:17px;font-weight:bold;color:#3b74d7;margin-top:5px;display:inline-block;text-decoration:none;&:hover{text-decoration:underline;}']);\n\t\n\tvar MaybeApiGuide = function MaybeApiGuide(props) {\n\t  return _react2.default.createElement(\n\t    _layout2.default,\n\t    { location: props.location },\n\t    _react2.default.createElement(\n\t      'h1',\n\t      null,\n\t      'MaybeAsync and EitherAsync for Haskellers'\n\t    ),\n\t    'As mentioned in the description of those data types, MaybeAsync and EitherAsync are funky Promise-specialized monad transformers for Maybe and Either.',\n\t    _react2.default.createElement('br', null),\n\t    'Some things may feel out of place and that is completely intentional, porting monad transformers over to TypeScript was just not practical, especially the higher-kinded types and typeclasses part.',\n\t    _react2.default.createElement('br', null),\n\t    'A lot of thought went into designing the APIs and I believe that the result is satisfactory. In fact, even though the implementation is completely different, code written in mtl style looks pretty similar! Here, take a look:',\n\t    _react2.default.createElement(\n\t      _reactSyntaxHighlighter2.default,\n\t      { language: 'haskell', style: _googlecode2.default },\n\t      'tryToInsertUser user = runExceptT $ do\\n  validatedUser <- liftEither $ validateUser user\\n  userExists <- lift $ doesUserAlreadyExist validatedUser\\n\\n  when userExists (throwE UserAlreadyExists)\\n\\n  maybeToExceptT ServerError $ do\\n    updatedUser <- MaybeT $ hashPasswordInUser user\\n    lift $ insertUser updatedUser'\n\t    ),\n\t    'Keep in mind this code is not representative of the perfect or cleanest implementation for such a feature, I tried to shove as much functions, that are also possible in Maybe-EitherAsync, as I could.',\n\t    _react2.default.createElement('br', null),\n\t    'Here\\'s the same logic implemented with purify in TypeScript:',\n\t    _react2.default.createElement(\n\t      _reactSyntaxHighlighter2.default,\n\t      { language: 'typescript', style: _googlecode2.default },\n\t      'const tryToInsertUser = user =>\\n  EitherAsync(async ({ liftEither, throwE, fromPromise }) => {\\n    const validatedUser = await liftEither(validateUser(user))\\n    const userExists = await doesUserAlreadyExist(validatedUser)\\n\\n    if (userExists) throwE(\\'UserAlreadyExists\\')\\n\\n    return fromPromise(MaybeAsync(async ({ fromPromise }) => {\\n        const updatedUser = await fromPromise(hashPasswordInUser(user))\\n        return insertUser(updatedUser)\\n    }).toEitherAsync(\\'ServerError\\').run())\\n  })'\n\t    ),\n\t    'One important thing to understand about Maybe and EitherAsync is that the docs and the API create the illusion that code is running in some custom magical context that lets you safely unwrap values.',\n\t    _react2.default.createElement('br', null),\n\t    'Is it referred to as \"MaybeAsync context\" or \"EitherAsync context\", but in fact there\\'s no magic and the only real context is the async/await block.',\n\t    _react2.default.createElement('br', null),\n\t    'That allows us to simulate do-notation using await and what those \"lifting\" function actually do is return Promises that get rejected when a value is missing. ',\n\t    _react2.default.createElement('br', null),\n\t    'The `run` function will later on catch all those rejections and return a proper Maybe/Either value.',\n\t    _react2.default.createElement(\n\t      'h3',\n\t      null,\n\t      'Glossary of functions'\n\t    ),\n\t    _react2.default.createElement(\n\t      'ul',\n\t      null,\n\t      _react2.default.createElement(\n\t        'li',\n\t        null,\n\t        'MaybeAsync<a>',\n\t        ' = MaybeT IO a'\n\t      ),\n\t      _react2.default.createElement(\n\t        'li',\n\t        null,\n\t        'EitherAsync<e, a>',\n\t        ' = ExceptT e IO a'\n\t      ),\n\t      _react2.default.createElement(\n\t        'li',\n\t        null,\n\t        'liftEither/Maybe = liftEither/Maybe (',\n\t        _react2.default.createElement(\n\t          _HL2.default,\n\t          null,\n\t          'MaybeT/ExceptT . return'\n\t        ),\n\t        ' in Haskell, but nothing like that in purify, they function the same though)'\n\t      ),\n\t      _react2.default.createElement(\n\t        'li',\n\t        null,\n\t        'fromPromise = the MaybeT/ExceptT constructor (you only need to wrap the IO action with the newtype in Haskell, in purify it\\'s not as simple)'\n\t      ),\n\t      _react2.default.createElement(\n\t        'li',\n\t        null,\n\t        'throwE = throwE'\n\t      ),\n\t      _react2.default.createElement(\n\t        'li',\n\t        null,\n\t        'MaybeAsync#toEitherAsync = maybeToExceptT (from the',\n\t        ' ',\n\t        _react2.default.createElement(\n\t          'a',\n\t          { href: 'http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Maybe.html#v:maybeToExceptT' },\n\t          'transformers package'\n\t        ),\n\t        ')'\n\t      ),\n\t      _react2.default.createElement(\n\t        'li',\n\t        null,\n\t        'EitherAsync#toMaybeAsync = exceptToMaybeT'\n\t      )\n\t    )\n\t  );\n\t};\n\t\n\texports.default = MaybeApiGuide;\n\tmodule.exports = exports['default'];\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// component---src-pages-guides-maybeasync-eitherasync-for-haskellers-js-4b56acda1ac5f39c23ff.js","import React from 'react'\r\nimport styled from 'styled-components'\r\nimport Layout from '../../components/layout'\r\nimport HL from '../../components/HL'\r\nimport SyntaxHighlighter from 'react-syntax-highlighter'\r\nimport highlightStyle from 'react-syntax-highlighter/styles/hljs/googlecode'\r\n\r\nconst Note = styled.div`\r\n  display: inline-block;\r\n  background-color: #fcf4cd;\r\n  border: 0 solid #f7e070;\r\n  border-left-width: 8px;\r\n  padding: 10px;\r\n  margin: 10px 0;\r\n`\r\n\r\nconst MethodName = styled.a`\r\n  font-size: 17px;\r\n  font-weight: bold;\r\n  color: #3b74d7;\r\n  margin-top: 5px;\r\n  display: inline-block;\r\n  text-decoration: none;\r\n\r\n  &:hover {\r\n    text-decoration: underline;\r\n  }\r\n`\r\n\r\nconst MaybeApiGuide = props => (\r\n  <Layout location={props.location}>\r\n    <h1>MaybeAsync and EitherAsync for Haskellers</h1>\r\n    As mentioned in the description of those data types, MaybeAsync and\r\n    EitherAsync are funky Promise-specialized monad transformers for Maybe and\r\n    Either.<br />\r\n    Some things may feel out of place and that is completely intentional,\r\n    porting monad transformers over to TypeScript was just not practical,\r\n    especially the higher-kinded types and typeclasses part.<br />\r\n    A lot of thought went into designing the APIs and I believe that the result\r\n    is satisfactory. In fact, even though the implementation is completely\r\n    different, code written in mtl style looks pretty similar! Here, take a\r\n    look:\r\n    <SyntaxHighlighter language=\"haskell\" style={highlightStyle}>\r\n      {`tryToInsertUser user = runExceptT $ do\r\n  validatedUser <- liftEither $ validateUser user\r\n  userExists <- lift $ doesUserAlreadyExist validatedUser\r\n\r\n  when userExists (throwE UserAlreadyExists)\r\n\r\n  maybeToExceptT ServerError $ do\r\n    updatedUser <- MaybeT $ hashPasswordInUser user\r\n    lift $ insertUser updatedUser`}\r\n    </SyntaxHighlighter>\r\n    Keep in mind this code is not representative of the perfect or cleanest\r\n    implementation for such a feature, I tried to shove as much functions, that\r\n    are also possible in Maybe-EitherAsync, as I could.<br />\r\n    Here's the same logic implemented with purify in TypeScript:\r\n    <SyntaxHighlighter language=\"typescript\" style={highlightStyle}>\r\n      {`const tryToInsertUser = user =>\r\n  EitherAsync(async ({ liftEither, throwE, fromPromise }) => {\r\n    const validatedUser = await liftEither(validateUser(user))\r\n    const userExists = await doesUserAlreadyExist(validatedUser)\r\n\r\n    if (userExists) throwE('UserAlreadyExists')\r\n\r\n    return fromPromise(MaybeAsync(async ({ fromPromise }) => {\r\n        const updatedUser = await fromPromise(hashPasswordInUser(user))\r\n        return insertUser(updatedUser)\r\n    }).toEitherAsync('ServerError').run())\r\n  })`}\r\n    </SyntaxHighlighter>\r\n    One important thing to understand about Maybe and EitherAsync is that the\r\n    docs and the API create the illusion that code is running in some custom\r\n    magical context that lets you safely unwrap values.<br />\r\n    Is it referred to as \"MaybeAsync context\" or \"EitherAsync context\", but in\r\n    fact there's no magic and the only real context is the async/await block.<br />\r\n    That allows us to simulate do-notation using await and what those \"lifting\"\r\n    function actually do is return Promises that get rejected when a value is\r\n    missing. <br />\r\n    The `run` function will later on catch all those rejections and return a\r\n    proper Maybe/Either value.\r\n    <h3>Glossary of functions</h3>\r\n    <ul>\r\n      <li>{'MaybeAsync<a>'} = MaybeT IO a</li>\r\n      <li>{'EitherAsync<e, a>'} = ExceptT e IO a</li>\r\n      <li>\r\n        liftEither/Maybe = liftEither/Maybe (<HL>MaybeT/ExceptT . return</HL> in\r\n        Haskell, but nothing like that in purify, they function the same though)\r\n      </li>\r\n      <li>\r\n        fromPromise = the MaybeT/ExceptT constructor (you only need to wrap the\r\n        IO action with the newtype in Haskell, in purify it's not as simple)\r\n      </li>\r\n      <li>throwE = throwE</li>\r\n      <li>\r\n        MaybeAsync#toEitherAsync = maybeToExceptT (from the{' '}\r\n        <a href=\"http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Maybe.html#v:maybeToExceptT\">\r\n          transformers package\r\n        </a>)\r\n      </li>\r\n      <li>EitherAsync#toMaybeAsync = exceptToMaybeT</li>\r\n    </ul>\r\n  </Layout>\r\n)\r\n\r\nexport default MaybeApiGuide\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/guides/maybeasync-eitherasync-for-haskellers.js"],"sourceRoot":""}