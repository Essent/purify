{"version":3,"sources":["webpack:///component---src-pages-guides-maybe-api-guide-js-24884e427e223e5bc698.js","webpack:///./src/pages/guides/maybe-api-guide.js"],"names":["webpackJsonp","227","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_react","_react2","_styledComponents","_styledComponents2","_layout","_layout2","_HL","_HL2","_reactSyntaxHighlighter","_reactSyntaxHighlighter2","_googlecode","_googlecode2","Note","styled","div","withConfig","displayName","MethodName","a","SmallMethodName","MaybeApiGuide","props","createElement","location","href","language","style","highlightStyle"],"mappings":"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","file":"component---src-pages-guides-maybe-api-guide-js-24884e427e223e5bc698.js","sourcesContent":["webpackJsonp([98857381193334],{\n\n/***/ 227:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _styledComponents = __webpack_require__(8);\n\t\n\tvar _styledComponents2 = _interopRequireDefault(_styledComponents);\n\t\n\tvar _layout = __webpack_require__(21);\n\t\n\tvar _layout2 = _interopRequireDefault(_layout);\n\t\n\tvar _HL = __webpack_require__(47);\n\t\n\tvar _HL2 = _interopRequireDefault(_HL);\n\t\n\tvar _reactSyntaxHighlighter = __webpack_require__(19);\n\t\n\tvar _reactSyntaxHighlighter2 = _interopRequireDefault(_reactSyntaxHighlighter);\n\t\n\tvar _googlecode = __webpack_require__(24);\n\t\n\tvar _googlecode2 = _interopRequireDefault(_googlecode);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Note = _styledComponents2.default.div.withConfig({\n\t  displayName: 'maybe-api-guide__Note'\n\t})(['display:inline-block;background-color:#fcf4cd;border:0 solid #f7e070;border-left-width:8px;padding:10px;margin:10px 0;']);\n\t\n\tvar MethodName = _styledComponents2.default.a.withConfig({\n\t  displayName: 'maybe-api-guide__MethodName'\n\t})(['font-size:17px;font-weight:bold;color:#3b74d7;margin-top:5px;display:inline-block;text-decoration:none;&:hover{text-decoration:underline;}']);\n\t\n\tvar SmallMethodName = (0, _styledComponents2.default)(MethodName).withConfig({\n\t  displayName: 'maybe-api-guide__SmallMethodName'\n\t})(['font-size:initial;font-weight:initial;margin-top:0;']);\n\t\n\tvar MaybeApiGuide = function MaybeApiGuide(props) {\n\t  return _react2.default.createElement(\n\t    _layout2.default,\n\t    { location: props.location },\n\t    _react2.default.createElement(\n\t      'h1',\n\t      null,\n\t      'Which Maybe method am I supposed to use now? (API guide)'\n\t    ),\n\t    'We\\'ve all been in that research phase where we\\'re still learning the API of library and deciding if it suits our usecases. ',\n\t    _react2.default.createElement('br', null),\n\t    'The purpose of this guide is to make that process easier by grouping all available methods for the Maybe data type.',\n\t    _react2.default.createElement(\n\t      'h3',\n\t      null,\n\t      'Scenario #1 - I want to use Maybe but my codebase already has null/undefined all over the place'\n\t    ),\n\t    'One of purify\\'s main goals is great interoperability with existing code. That is why the API for Maybe is rich in utility methods for working with nullable values. ',\n\t    _react2.default.createElement('br', null),\n\t    _react2.default.createElement(\n\t      Note,\n\t      null,\n\t      'One might question the usage of Maybe (and purify) if you are still going to use nulls, there are already a lot of utility libraries like ramda and lodash that allow you to do that. ',\n\t      _react2.default.createElement('br', null),\n\t      'With purify you can start using ubiquitous data structures that come with a lot of literature and examples in various programming languages ',\n\t      _react2.default.createElement('br', null),\n\t      'without sacrificing coding style or ease of interop, that\\'s why using it instead of other libraries might be a good idea.'\n\t    ),\n\t    _react2.default.createElement('br', null),\n\t    _react2.default.createElement(\n\t      MethodName,\n\t      { href: '/adts/Maybe/#fromNullable' },\n\t      'Maybe.fromNullable'\n\t    ),\n\t    ' ',\n\t    '/ ',\n\t    _react2.default.createElement(\n\t      MethodName,\n\t      { href: '/adts/Maybe/#fromFalsy' },\n\t      'Maybe.fromFalsy'\n\t    ),\n\t    ' /',\n\t    ' ',\n\t    _react2.default.createElement(\n\t      MethodName,\n\t      { href: '/adts/Maybe/#fromPredicate' },\n\t      'Maybe.fromPredicate'\n\t    ),\n\t    ' ',\n\t    '/ ',\n\t    _react2.default.createElement(\n\t      MethodName,\n\t      { href: '/adts/Maybe/#encase' },\n\t      'Maybe.encase'\n\t    ),\n\t    _react2.default.createElement('br', null),\n\t    'These methods allow you to construct Maybe values from, as the names suggest, nullable and falsy values or in the case of the',\n\t    ' ',\n\t    _react2.default.createElement(\n\t      SmallMethodName,\n\t      { href: '/adts/Maybe/#encase' },\n\t      'encase'\n\t    ),\n\t    ' method - from a function that may throw an exception. ',\n\t    _react2.default.createElement('br', null),\n\t    '`fromPredicate` is on the list because it can be used to cover all kinds of complicated checks, for example:',\n\t    _react2.default.createElement(\n\t      _reactSyntaxHighlighter2.default,\n\t      { language: 'javascript', style: _googlecode2.default },\n\t      'const _ = Maybe.fromPredicate(x => x && x.length > 0, value)'\n\t    ),\n\t    _react2.default.createElement(\n\t      MethodName,\n\t      { href: '/adts/Maybe/#chainNullable' },\n\t      'chainNullable'\n\t    ),\n\t    _react2.default.createElement('br', null),\n\t    'Now that you have constructed your Maybe out of an optional value, you may want to transform it with a function that returns yet another optional value. ',\n\t    _react2.default.createElement('br', null),\n\t    'If you are already familiar with the',\n\t    ' ',\n\t    _react2.default.createElement(\n\t      SmallMethodName,\n\t      { href: '/adts/Maybe/#chain' },\n\t      'chain'\n\t    ),\n\t    ' method (a.k.a. ',\n\t    _react2.default.createElement(\n\t      _HL2.default,\n\t      null,\n\t      'bind'\n\t    ),\n\t    ', ',\n\t    _react2.default.createElement(\n\t      _HL2.default,\n\t      null,\n\t      'flatMap'\n\t    ),\n\t    ' or ',\n\t    _react2.default.createElement(\n\t      _HL2.default,\n\t      null,\n\t      '>>='\n\t    ),\n\t    ') you may think of using it in combination with any of the methods mentioned above: ',\n\t    _react2.default.createElement('br', null),\n\t    _react2.default.createElement(\n\t      _reactSyntaxHighlighter2.default,\n\t      { language: 'javascript', style: _googlecode2.default },\n\t      'myMaybe.chain(x => Maybe.fromNullable(transform(x)))'\n\t    ),\n\t    'There\\'s nothing wrong with that approach, but there\\'s a helper method called `chainNullable` that does exactly the same thing ',\n\t    _react2.default.createElement('br', null),\n\t    'without you having to manually construct a Maybe out of the return value of the transformation function. ',\n\t    _react2.default.createElement('br', null),\n\t    _react2.default.createElement(\n\t      _reactSyntaxHighlighter2.default,\n\t      { language: 'javascript', style: _googlecode2.default },\n\t      'myMaybe.chainNullable(x => transform(x))\\n// or just straight up\\nmyMaybe.chainNullable(transform)'\n\t    ),\n\t    _react2.default.createElement(\n\t      MethodName,\n\t      { href: '/adts/Maybe/#extract' },\n\t      'extract'\n\t    ),\n\t    ' /',\n\t    ' ',\n\t    _react2.default.createElement(\n\t      MethodName,\n\t      { href: '/adts/Maybe/#extractNullable' },\n\t      'extractNullable'\n\t    ),\n\t    ' ',\n\t    '/ ',\n\t    _react2.default.createElement(\n\t      MethodName,\n\t      { href: '/adts/Maybe/#unsafeCoerce' },\n\t      'unsafeCoerce'\n\t    ),\n\t    _react2.default.createElement('br', null),\n\t    'Sometimes you have to interact with code that expects a nullable value, in that case you can just unwrap a Maybe down to a primitive value like null or undefined using the methods above. ',\n\t    _react2.default.createElement('br', null),\n\t    _react2.default.createElement(\n\t      Note,\n\t      null,\n\t      'Please note that while you may be tempted to wrap and unwrap manually every time you encounter a nullable value, ',\n\t      _react2.default.createElement('br', null),\n\t      'consider that code designed with Maybe in mind is easier to maintain and use in the long term. ',\n\t      _react2.default.createElement('br', null),\n\t      'Try to keep usage of the methods mentioned in this part of the guide low and only for compatibility reasons. ',\n\t      _react2.default.createElement('br', null),\n\t      'Don\\'t be afraid to start returning or expecing Maybe values in functions, you\\'ll notice some benefits you haven\\'t considered before!'\n\t    ),\n\t    _react2.default.createElement(\n\t      'h3',\n\t      null,\n\t      'Scenario #2 - I\\'m not sure how to check if a value exists or not'\n\t    ),\n\t    'There are numerous ways to check if a value exists with purify, but I want to focus on the fact that you rarely need to do so explicitly.',\n\t    _react2.default.createElement('br', null),\n\t    'Try to split up your code into functions and then find ways to combine them using many of the available transformation methods like',\n\t    _react2.default.createElement('br', null),\n\t    _react2.default.createElement(\n\t      SmallMethodName,\n\t      { href: '/adts/Maybe/#map' },\n\t      'Maybe#map'\n\t    ),\n\t    ' or',\n\t    ' ',\n\t    _react2.default.createElement(\n\t      SmallMethodName,\n\t      { href: '/adts/Maybe/#chain' },\n\t      'Maybe#chain'\n\t    ),\n\t    ' or',\n\t    ' ',\n\t    _react2.default.createElement(\n\t      SmallMethodName,\n\t      { href: '/adts/Maybe/#extend' },\n\t      'Maybe#extend'\n\t    ),\n\t    ' ',\n\t    'or',\n\t    _react2.default.createElement(\n\t      SmallMethodName,\n\t      { href: '/adts/Maybe/#filter' },\n\t      'Maybe#filter'\n\t    ),\n\t    '... you get the point.',\n\t    _react2.default.createElement('br', null),\n\t    'There are so many methods you can chain so that your code is nice and declarative that you\\'ll almost never have to unpack a Maybe and check manually.',\n\t    _react2.default.createElement('br', null),\n\t    'There are some cases where that is needed though, let\\'s go through them:',\n\t    ' ',\n\t    _react2.default.createElement('br', null),\n\t    ' ',\n\t    _react2.default.createElement('br', null),\n\t    _react2.default.createElement(\n\t      MethodName,\n\t      { href: '/adts/Maybe/#isJust' },\n\t      'Maybe#isJust'\n\t    ),\n\t    ' /',\n\t    ' ',\n\t    _react2.default.createElement(\n\t      MethodName,\n\t      { href: '/adts/Maybe/#isNothing' },\n\t      'Maybe#isNothing'\n\t    ),\n\t    _react2.default.createElement('br', null),\n\t    'The most primitive of the bunch, these methods enable us to do JS-style checking if a value is missing or not.',\n\t    _react2.default.createElement('br', null),\n\t    'The method names are pretty self-explanatory so we won\\'t go into much details, but it\\'s generally not recommend to use those methods.',\n\t    _react2.default.createElement('br', null),\n\t    'Better choices are almost always available.',\n\t    _react2.default.createElement('br', null),\n\t    _react2.default.createElement('br', null),\n\t    _react2.default.createElement(\n\t      MethodName,\n\t      { href: '/adts/Maybe/#caseOf' },\n\t      'Maybe#caseOf'\n\t    ),\n\t    ' /',\n\t    ' ',\n\t    _react2.default.createElement(\n\t      MethodName,\n\t      { href: '/adts/Maybe/#reduce' },\n\t      'Maybe#reduce'\n\t    ),\n\t    _react2.default.createElement('br', null),\n\t    _react2.default.createElement(\n\t      SmallMethodName,\n\t      { href: '/adts/Maybe/#caseOf' },\n\t      'caseOf'\n\t    ),\n\t    ' is the go-to choice when none of the other methods seem good enough.',\n\t    _react2.default.createElement('br', null),\n\t    'Since pattern matching is still not available (yet) in JavaScript, caseOf tries to mimic this behaviour, allowing you to branch your logic by asking you for two functions that will handle each case.',\n\t    _react2.default.createElement('br', null),\n\t    _react2.default.createElement(\n\t      SmallMethodName,\n\t      { href: '/adts/Maybe/#reduce' },\n\t      'reduce'\n\t    ),\n\t    ' is very, very similar, in fact it\\'s so similar that it looks almost useless. The goal of reduce is to provide an instance for the Foldable typeclass for Maybe.',\n\t    _react2.default.createElement('br', null),\n\t    'If you like the minimalism of reduce and you don\\'t care about Foldable or you haven\\'t heard of it - no problem, you can use it instead of caseOf just fine!',\n\t    _react2.default.createElement('br', null)\n\t  );\n\t};\n\t\n\texports.default = MaybeApiGuide;\n\tmodule.exports = exports['default'];\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// component---src-pages-guides-maybe-api-guide-js-24884e427e223e5bc698.js","import React from 'react'\nimport styled from 'styled-components'\nimport Layout from '../../components/layout'\nimport HL from '../../components/HL'\nimport SyntaxHighlighter from 'react-syntax-highlighter'\nimport highlightStyle from 'react-syntax-highlighter/styles/hljs/googlecode'\n\nconst Note = styled.div`\n  display: inline-block;\n  background-color: #fcf4cd;\n  border: 0 solid #f7e070;\n  border-left-width: 8px;\n  padding: 10px;\n  margin: 10px 0;\n`\n\nconst MethodName = styled.a`\n  font-size: 17px;\n  font-weight: bold;\n  color: #3b74d7;\n  margin-top: 5px;\n  display: inline-block;\n  text-decoration: none;\n\n  &:hover {\n    text-decoration: underline;\n  }\n`\n\nconst SmallMethodName = styled(MethodName)`\n  font-size: initial;\n  font-weight: initial;\n  margin-top: 0;\n`\n\nconst MaybeApiGuide = props => (\n  <Layout location={props.location}>\n    <h1>Which Maybe method am I supposed to use now? (API guide)</h1>\n    We've all been in that research phase where we're still learning the API of\n    library and deciding if it suits our usecases. <br />\n    The purpose of this guide is to make that process easier by grouping all\n    available methods for the Maybe data type.\n    <h3>\n      Scenario #1 - I want to use Maybe but my codebase already has\n      null/undefined all over the place\n    </h3>\n    One of purify's main goals is great interoperability with existing code.\n    That is why the API for Maybe is rich in utility methods for working with\n    nullable values. <br />\n    <Note>\n      One might question the usage of Maybe (and purify) if you are still going\n      to use nulls, there are already a lot of utility libraries like ramda and\n      lodash that allow you to do that. <br />\n      With purify you can start using ubiquitous data structures that come with\n      a lot of literature and examples in various programming languages <br />\n      without sacrificing coding style or ease of interop, that's why using it\n      instead of other libraries might be a good idea.\n    </Note>\n    <br />\n    <MethodName href=\"/adts/Maybe/#fromNullable\">\n      Maybe.fromNullable\n    </MethodName>{' '}\n    / <MethodName href=\"/adts/Maybe/#fromFalsy\">Maybe.fromFalsy</MethodName> /{' '}\n    <MethodName href=\"/adts/Maybe/#fromPredicate\">\n      Maybe.fromPredicate\n    </MethodName>{' '}\n    / <MethodName href=\"/adts/Maybe/#encase\">Maybe.encase</MethodName>\n    <br />\n    These methods allow you to construct Maybe values from, as the names\n    suggest, nullable and falsy values or in the case of the{' '}\n    <SmallMethodName href=\"/adts/Maybe/#encase\">encase</SmallMethodName> method\n    - from a function that may throw an exception. <br />\n    `fromPredicate` is on the list because it can be used to cover all kinds of\n    complicated checks, for example:\n    <SyntaxHighlighter language=\"javascript\" style={highlightStyle}>\n      {`const _ = Maybe.fromPredicate(x => x && x.length > 0, value)`}\n    </SyntaxHighlighter>\n    <MethodName href=\"/adts/Maybe/#chainNullable\">chainNullable</MethodName>\n    <br />\n    Now that you have constructed your Maybe out of an optional value, you may\n    want to transform it with a function that returns yet another optional\n    value. <br />\n    If you are already familiar with the{' '}\n    <SmallMethodName href=\"/adts/Maybe/#chain\">chain</SmallMethodName> method\n    (a.k.a. <HL>bind</HL>, <HL>flatMap</HL> or <HL>>>=</HL>) you may think of\n    using it in combination with any of the methods mentioned above: <br />\n    <SyntaxHighlighter language=\"javascript\" style={highlightStyle}>\n      {`myMaybe.chain(x => Maybe.fromNullable(transform(x)))`}\n    </SyntaxHighlighter>\n    There's nothing wrong with that approach, but there's a helper method called\n    `chainNullable` that does exactly the same thing <br />\n    without you having to manually construct a Maybe out of the return value of\n    the transformation function. <br />\n    <SyntaxHighlighter language=\"javascript\" style={highlightStyle}>\n      {`myMaybe.chainNullable(x => transform(x))\n// or just straight up\nmyMaybe.chainNullable(transform)`}\n    </SyntaxHighlighter>\n    <MethodName href=\"/adts/Maybe/#extract\">extract</MethodName> /{' '}\n    <MethodName href=\"/adts/Maybe/#extractNullable\">extractNullable</MethodName>{' '}\n    / <MethodName href=\"/adts/Maybe/#unsafeCoerce\">unsafeCoerce</MethodName>\n    <br />\n    Sometimes you have to interact with code that expects a nullable value, in\n    that case you can just unwrap a Maybe down to a primitive value like null or\n    undefined using the methods above. <br />\n    <Note>\n      Please note that while you may be tempted to wrap and unwrap manually\n      every time you encounter a nullable value, <br />\n      consider that code designed with Maybe in mind is easier to maintain and\n      use in the long term. <br />\n      Try to keep usage of the methods mentioned in this part of the guide low\n      and only for compatibility reasons. <br />\n      Don't be afraid to start returning or expecing Maybe values in functions,\n      you'll notice some benefits you haven't considered before!\n    </Note>\n    <h3>Scenario #2 - I'm not sure how to check if a value exists or not</h3>\n    There are numerous ways to check if a value exists with purify, but I want\n    to focus on the fact that you rarely need to do so explicitly.<br />\n    Try to split up your code into functions and then find ways to combine them\n    using many of the available transformation methods like<br />\n    <SmallMethodName href=\"/adts/Maybe/#map\">Maybe#map</SmallMethodName> or{' '}\n    <SmallMethodName href=\"/adts/Maybe/#chain\">Maybe#chain</SmallMethodName> or{' '}\n    <SmallMethodName href=\"/adts/Maybe/#extend\">Maybe#extend</SmallMethodName>{' '}\n    or\n    <SmallMethodName href=\"/adts/Maybe/#filter\">\n      Maybe#filter\n    </SmallMethodName>... you get the point.<br />\n    There are so many methods you can chain so that your code is nice and\n    declarative that you'll almost never have to unpack a Maybe and check\n    manually.<br />\n    There are some cases where that is needed though, let's go through them:{' '}\n    <br /> <br />\n    <MethodName href=\"/adts/Maybe/#isJust\">Maybe#isJust</MethodName> /{' '}\n    <MethodName href=\"/adts/Maybe/#isNothing\">Maybe#isNothing</MethodName>\n    <br />\n    The most primitive of the bunch, these methods enable us to do JS-style\n    checking if a value is missing or not.<br />\n    The method names are pretty self-explanatory so we won't go into much\n    details, but it's generally not recommend to use those methods.<br />\n    Better choices are almost always available.<br />\n    <br />\n    <MethodName href=\"/adts/Maybe/#caseOf\">Maybe#caseOf</MethodName> /{' '}\n    <MethodName href=\"/adts/Maybe/#reduce\">Maybe#reduce</MethodName>\n    <br />\n    <SmallMethodName href=\"/adts/Maybe/#caseOf\">caseOf</SmallMethodName> is the\n    go-to choice when none of the other methods seem good enough.<br />\n    Since pattern matching is still not available (yet) in JavaScript, caseOf\n    tries to mimic this behaviour, allowing you to branch your logic by asking\n    you for two functions that will handle each case.<br />\n    <SmallMethodName href=\"/adts/Maybe/#reduce\">reduce</SmallMethodName> is\n    very, very similar, in fact it's so similar that it looks almost useless.\n    The goal of reduce is to provide an instance for the Foldable typeclass for\n    Maybe.<br />\n    If you like the minimalism of reduce and you don't care about Foldable or\n    you haven't heard of it - no problem, you can use it instead of caseOf just\n    fine!<br />\n  </Layout>\n)\n\nexport default MaybeApiGuide\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/guides/maybe-api-guide.js"],"sourceRoot":""}